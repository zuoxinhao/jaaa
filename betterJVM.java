package work;

import java.util.*;
import java.util.stream.Collectors;
import java.lang.*;


public class betterJVM {
	
	//目的：补充对于JVM的理解，以及进行JVM的调优
	
	//1. eden区，survivor区算法：***这里就是标记复制算法，复制到1区或者2区
	//eden区占80%，survivor1占10%，survivor2占10%
	//垃圾先放入eden区，第一次minorGC,存活的eden区的进入survivor1区；
	//然后第二次minorGC,eden区和survivor1区存活的共同进入survivor2区
	//第三次，eden区和survivor2区存活的进入survivor1区......
	//总结：每次都只会有10%用于复制（放入survivor1或者survivor2），其他的直接清空。
	//这个10%怎么来的？  大量实际使用经验统计而来，每次minorGC年轻代存活概率只有10%左右。
	
	
	//2. 垃圾回收系统：
	//serial：单线程，卡顿
	//parallel：多线程，并行，卡顿
	//CMS：并发，系统和GC并发执行，多线程
	//CMS三色标记法：用于标记垃圾非垃圾（标记可到达的，标完后为白色的清除）
	//白色：未遍历到   黑色：本身遍历到且他的所有孩子遍历过   灰色：本身遍历到且有孩子未遍历到
	//所以每次GC线程都是从灰色继续就可以，不用从头开始
	//存在的不足：业务逻辑修改了引用，取消了灰色B到白色D，添加了黑色A指向白色D，A.d=D，然后在运行GC，导致出错。
	//*****解决办法：增长更新，添加一个屏障，每当JVM观察到黑色引用指向白色的时候，那就自动添加屏障，把黑色变成灰色，然后再从本次的灰色继续开始
	//*****隐蔽的问题：GC多线程问题，GC1线程标记A的一个属性（没引用，null），第二个属性暂时没来得及标；然后业务逻辑把第一个属性连接到了D，添加了引用；
	//然后GC2线程判断A，发现是灰色；但是GC1继续运行，他以为属性1判断过了，继续判断属性2，然后整个标完了，设置为黑色；这样子A明明添加了引用，但是由于GC1忽略了它
	//产生漏标问题。主要问题核心点在于属性标完后就不会再回溯该属性了，继续下一个属性了（*****这是多个垃圾线程的并发问题，增长更新解决的是垃圾线程和业务线程的并发问题）。
	//解决属性回溯问题：remark,重新标记
	
	
	//3. G1，ZGC：
	//同CMS三色标记，只不过不再用增长更新解决问题，而是用SATB，snapshot（保存快照，单独处理）
	//直接把灰色B到D记录下来，尤其是D，将D用于后面单独处理
	//G1用的是分区模型，分代都是很大内存区域用于一部分，但是分区，使得同一代分成好多小区域，这样子就不用集体回收，而是部分回收部分可用，效率更高
	//内存没怎么满，只是分区满了就会开始回收，所以G1的效率极高。
	//ZGC：用内存外的指针地址变化来进行GC，简单了解颜色指针法
	
	
	//4. JVM调优命令：
	//top命令查看占用CPU,内存的线程；jstack定位线程，主要是死锁问题；jps:查看具体线程；-Xms初始内存，-Xmx最大内存；*****jmap查看占用内存的具体对象（用于分析OOM找到不断占用内存的对象）
	//阿里的arthas可代替命令行调优来处理，通过特定的arthas链接到具体线程，然后后面的分析在arthas里面处理，arthas命令简单易懂
	//*****arthas里面有个命令redefine可以直接重新定义class类，在不用停服务器的情况下实现修改版本。
	//FGC频繁会导致最后出现OOM（意思就是内存里面全是有用的有引用的，没有太多垃圾可清理），GC日志文件需要设置滚动日志
	//注意：jmap命令对于大内存不适用，会出现卡顿，但是在分布式集群中可用，停掉一个服务器不影响
	//***主要的调优是找到OOM的原因：用top查线程，用jps定位具体线程，jmap去查看什么样的对象导致的
	//***top---jps---jmap
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

}
