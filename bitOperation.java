package work;

import java.util.*;
import java.util.stream.Collectors;
import java.lang.*;



public class bitOperation {
	
	//*****位运算总结：
	//1. *****几个位运算：^,&,|,~；  x^x=0,x^0=x,x^11111111=~x(和全1相异或，1--0，0--1，即每个位都取反)
	//2. n&(n-1)可以去除n表示中位级最低的一位1（最低的一位1变成0），去除最低位1
	//3. *****求n二进制中1/0的个数：用n&1:1其实是00000001，n转化为二进制，按位与，高位都是0，只有最后一位可能是1/0
	//直接和1相与，得到最后一位的值，然后用n>>1,算术右移，然后继续与，得到下一位1/0
	//*****1代表00000000001，相与的时候，其他位置都是0，相与肯定是0，所以最后结果要么1要么0
	//4. 和1相与得到最后一位数字，然后算数右移即可
	//6. *****对应位置置1：和对应位1相或，用 | 100000（k个）
	//7. *****n&(-n)直接得到最低的那一位1所在的位置
	//9. *****二进制翻转：n&1得到当前最后一位数，n>>1开始下一位。想要翻转，用res来存，每次res先<<1,再加上n&1,即可。
	//将res先左移后加最后一位，然后继续下一次迭代。
	//10. *****用26位的二进制数来表示26个字母出现与否：ch-'a'得到当前字符属于第k位, 1<<k得到对应第k位为1的数
	//然后把初始数和1<<k相或即可得到这个26位的二进制数
	//11. *****注意位运算的优先级很低，低于=><，所以复合运算时候千万别忘了位运算加()
	//12. 巧妙：统计1-n中每个数二进制1的个数：
	//设dp[i]是i对应二进制数中1的个数，如果最后1位是1，则dp[i]=dp[i-1]+1;不是1，dp[i]=dp[i>>1]
	//13. *****找到最高位的1：用的是十进制的范围，2^i<=num<2^(i+1),2^i用的是1<<i;注意一下32位int最高位为符号位
	//14. 476重点题
	//15. 很巧妙：寻找两个孤独数：首先相异或得到x=x1^x2;然后用x^(-x)得到x中最低位的1所在位置(1000...假设为m)，该位置处x1和x2必然是1和0；
	//然后根据该位置的1/0将原数组划分为两个子数组(nums[i]&m)，x1,x2必然分属不同子数组，其他元素成对出现在其中一个子数组；最后两个子数组分别
	//异或，即可得到x1和x2
	
	
	
	
	//461：汉明距离
	//求二进制表示中不同位的个数：不同位---用异或，然后求结果中1的个数
	 public int hammingDistance(int x, int y) {
         int res=0;
         int diff=x^y;
         while(diff!=0) {
        	 res+=diff&1;
        	 diff>>=1;
         }
         return res;
	    }
	 
	 //190：颠倒二进制位
	 //基本的，res先左移，然后加上n的末尾，然后n右移
	 //为什么要先左移？因为for循环的原因，如果是先加后左移右移，会导致第32次循环时，加上了最后一个位数，但是又再次左移，相当于扩大了2倍，结果*2
	 //先左移后加：先左移会导致0---00，实际上没影响的，比如n末尾1，那就是0---00---01，实际上01和1是一个概念，前面的0没有意义，所以是先左移后加
	 public int reverseBits(int n) {
	     int res=0;
	     for(int i=0;i<32;i++) {
	    	 res<<=1;                  
	    	 res+=n&1;                      
	    	 n>>=1;
	     }
	     return res; 
	    }
	 
	 //136:仅出现一次的数
	 //空间复杂度O（1）的解法：利用异或，x^x^y=0^y=y
	 //所以所有的都异或---得到y
	 public int singleNumber(int[] nums) {
		 int res=0;
		 for(int i=0;i<nums.length;i++) {
			 res^=nums[i];
		 }
		 return res;
	    }
	 
	 //342:4的次方
	 public boolean isPowerOfFour(int n) {
		 while(n!=0&&n%4==0) {
			 n/=4;
		 }
		 return n==1;
	    }
	 //也可以用位运算（比较复杂）：先判断2的幂次：2的幂次，二进制表示中仅有一个1，所以用n&(n-1)消掉这个1，为0就是2的幂次
	 //4的幂次：在二进制表示中，也是仅有一个1，而且这个1必然在奇数位上，比如：16----10000.所以我们用一个来消掉奇数位的这个1，比如：01010，奇数位都是0，和原数字相与，奇数位--变0
	 //偶数位本身就是0，相与也是0，所以得到的就是0，综上，满足2的幂次，且用1010101010..0相与后为0的就是4的幂次
	
	 //318：不相交字符的最大长度积
	 //总思路很简单：求每一个和其他的不相交的长度积即可，O(n^2)
	 //关键在于如何求不相交：位运算，用26位数来表示26个字母是否存在，存在置1，不存在置0，然后两个字符对应的数相与为0，不相交，不是0就是相交
	 //怎么用26位数来表示字母：位上字符ch,ch-'a'得到和第0位的差值k，然后就是将k位置1，方法：将数字1<<k,得到10000(k个0)，然后和基本数相或---就可以得到对应位置置1了
	 public int maxProduct(String[] words) {
		 int m=words.length;
		 int[] mask=new int[m];
		 for(int i=0;i<m;i++) {
			 String str=words[i];
			 int len=str.length();
			 for(int j=0;j<len;j++) {
				 mask[i]|=1<<(str.charAt(j)-'a');
			 }
		 }
		 int max=0;
		 for(int i=0;i<m;i++) {
			 for(int j=i+1;j<m;j++) {
				 if((mask[i]&mask[j])==0) {                           //!!!位运算优先级没有==高，所以位运算最好（）起来
					 max=Math.max(max, words[i].length()*words[j].length());
				 }
			 }
		 }
		 return max;
	    }
	 
	 //338：二进制中1的个数
	 //暴力：对于每个数，用&1.>>即可
	 //动规：设dp[i]是i对应二进制数中1的个数，如果最后1位是1，则dp[i]=dp[i-1]+1;不是1，dp[i]=dp[i>>1]
	 //初值dp[0]=0
	 public int[] countBits(int n) {
		 int[] dp=new int[n+1];
		 for(int i=1;i<n+1;i++) {
			 dp[i]=(i&1)==1?dp[i-1]+1:dp[i>>1];
		 }
         return dp;
	    }
	 
	 //238:寻找丢失的一个数
	 //因为[0,n]只有一个数丢失，所以想到了二进制的异或可以判断孤独数，所以可以扩充[0,n]加入数组，也可以直接先[0,n]异或再去和原数组异或即可
	 public int missingNumber(int[] nums) {
		 int res=0;
		 int n=nums.length;
		 for(int i=1;i<=n;i++) {
			 res^=i;
		 }
		 for(int i=0;i<n;i++) {
			 res^=nums[i];
		 }
		 return res;
	    }
	 
	 //693：交替二进制数
	 //先在循环外求出第一个，然后再去循环内交替判断两次
	 public boolean hasAlternatingBits(int n) {
		 int x=n&1;
		 n>>=1;
		 while(n!=0) {
			 int y=n&1;
			 if(x==y) return false;
			 n>>=1;
			 if(n==0) return true;
			 x=n&1;
			 if(x==y) return false;
			 n>>=1;
		 }
		 return true;
	    }
	 
	 //476：二进制1-0，0-1取反
	 //主要问题：一共32位，有一个符号位；其他的还有最高位1上面的0是无意义的
	 //所以要先找到最高位的1，假设是第i位，然后取所有有效位都是1，即2^(i+1)-1,用异或即可得到结果。
	 //求最高位1所在位置：用的是范围：第i位（i从0开始）位1时，他的十进制范围是：2^i<= 值 <2^(i+1)
	 public int findComplement(int num) {
		 int height=0;
		 for(int i=1;i<=30;i++) {
			 if(num>=(1<<i)) {                      //找到最高位的1，将1不断地左移，就是2^0,2^1,2^2...2^i
				 height=i;
			 }else {
				 break;
			 }
		 }
		 int mask=(height==30)?0x7fffffff:(1<<(height+1))-1;  //如果第30位是1时候，就不能再向前+1次-1，会出错的；所以要有区分。
         return num^mask;
	    }
	
	 //260：寻找两个孤独数
	 //很巧妙
	 //两个也是先异或得到：x=x1^x2;然后求取x的二进制中第一个为1的最低位，即x&-x;对于这个1来说，x1，x2在该位置必然是不同的数字0和1
	 //所以我们用该位置的0和1来进行分类nums,x1,x2在不同类中，其他的元素因为是成对出现，相同的两个在同一类中，这时我们对两个类分别再异或，就得到了x1,x2
	 public int[] singleNumber260(int[] nums) {
		 int x=0;
		 for(int i=0;i<nums.length;i++) {
			 x^=nums[i];
		 }
		 int m=(x==Integer.MAX_VALUE)?x:x&(-x);        //得到最低位1所在位置
		 int type1=0;
		 int type2=0;
		 for(int i=0;i<nums.length;i++) {
			 if((nums[i]&m)!=0) {                      //按最低位1来区分
				 type1^=nums[i];                       //!!!!!和m（000100000...）相与：如果此位为0，相与得到0，此位为1，相与得到就是m
			 }else {
				 type2^=nums[i];
			 }
		 }
		 return new int[] {type1,type2};
	    }
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

}

