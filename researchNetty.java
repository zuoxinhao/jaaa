package work;

public class researchNetty {
	
	//Netty这边大致的了解了下，后面有机会再补充
	
	
	//1.Netty架构概述：
	//(1) Java中用serverSocket和Socket类来实现服务端和客户端连接，但是高性能如Http协议需要用户自己去写
	//(2) Netty:不需要考虑高性能，IO细节，编码解码，使用Netty框架的接口会自动实现这些
	//(3) Netty使用：只需要写一些客户端服务端handler接口，重写好方法体就行(事件驱动)
	//(4) 责任链模式处理客户端数据：Pipeline流水线，一系列handler来共同处理，比如：HTTP解码HTTPCodecHandler--GZIP压缩解码Handler--业务处理Handler
	//业务处理完后可以通过HTTPhandler编码器等再传给客户端.
	//总结，组合编码：客户端-----解码器(OutBound)-----服务端-----业务逻辑-----编码器(InBound)-----客户端
	//(5) Netty构成：传输模块(TCP/UDP等的基础JAVA实现)，协议模块(组合编码，协议)，核心模块(事件模型，多线程模型，自建内存管理)
	
	//2.Netty线程池和事件响应模型：
	//(1) Netty的线程池：负责在请求到来时取调用Handler
	//(2) 个数限制：默认为CPU核心数*2，可以通过Math.max(io.netty,eventLoopThreads,CPU个数*2) 设置。
	//(3) 在handler里面调用IO操作(比如Thread.sleep(1000)),会导致阻塞，默认最多并发执行的是CPU*2，如何解决？开启业务线程池，处理IO任务
	//(4) *****响应式编程Reactor事件驱动模型：根据不同事件，回调不同动作，完成业务逻辑；把一个业务逻辑拆分为几个阶段，每个阶段均用发事件的方式来进行处理。
	//*****异步模型：处理一个任务的时候不会阻塞另一个任务，并发执行                   同步模型：几个事件必须逐个执行，也就是顺序执行
	//(5) *****Netty的事件处理：mainReactor主响应器用于单线程接收客户端连接---subReactor:从响应器用于多线程异步处理事件   
	
	//3. 同步异步阻塞非阻塞详解：
	//(1) 同步异步的主要区别：执行一个任务会不会导致整个流程等待，异步就是并发执行，同步就是顺序执行
	//(2) 阻塞非阻塞的主要区别：操作条件不满足时候会不会发一个标志信息告知不满足，然后执行其他任务；阻塞的就一直等待，非阻塞的会发一个标志然后跳到其他任务
	//(3) 关注的点不一样，同步异步是对于不同任务而言的顺序和并发，阻塞非阻塞是对于一个任务执行过程中遇到问题的处理
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

}
